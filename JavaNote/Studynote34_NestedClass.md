# 嵌套类/内部类

●类的五大成员：属性、方法、构造器、代码块、内部类

```java
package 包名
class 类名 extends 父类 implements 接口名{
    成员变量/属性
    构造方法/构造器
    成员方法/方法
    代码块
}
```

## 内部类

定义在类里面的类。最大的特点就是可以直接访问私有属性，并且可以体现类与类之间的包含关系

●基本语法

```java
class Outer{//外部类
    class Inner{//内部类

    }
}
class Other{}//其他类

```



### 分类

定义在外部类局部位置上（比如方法内）：
1）局部内部类（有类名）
2）匿名内部类（没有类名，重点）

定义在外部类的成员位置上：
1）成员内部类（没用static修饰）
2）静态内部类（使用static修饰）

## 局部内部类

说明：局部内部类是定义在外部类的局部位置，比如方法中，并且有类名。
1.可以直接访问外部类的所有成员，包含私有的
2.不能添加访问修饰符，因为它的地位就是一个局部变量。局部变量是不能使用修饰符的。
但是可以使用final修饰，因为局部变量也可以使用final
3.作用域：仅仅在定义它的方法或代码块中
4.局部内部类 --访问->外部类的成员[访问方式：直接访问]
5.外部类 -访问-> 局部内部类的成员[访问方式：创建对象，调用方法（注意：必须在作用域内）]
6.外部其他类 -不能访问-> 局部内部类（因为局部内部类地位是一个局部变量）
7.如果外部类和局部内部类的成员重名时，默认遵循就近原则，如果想访问外部类的成员，则可以使用（外部类名.this.成员）去访问
System.out.println（"外部类的n2="+外部类名.this.n2）

//因为在方法中，所以当成方法的一个局部变量，不过是以类的形式而存在的，所以可以访问外部类的成员
//但是不能添加访问修饰符，作用域也仅仅在定义它的方法或代码中，要使用也只能在方法中实例化对象

//外部类通过在方法体中创建局部内部类的实例化 调用局部内部类成员 的成员，然后在主方法中
//创建外部类的实例，调用，方法，方法里有内部类的实例，然后内部类的实例最后调用内部类的

1：个人理解：使用局部内部类的情况为当一个类里面需要反复使用到某段方法时，可以封装成一个类给该类内部使用，
2：内部类是私有的给自己内部使用的，还可以使用final线程安全上方法也有所不同

●关于局部内部类需要记住的内容：
1）定义域：方法体/代码块
2）作用域：方法体/代码块
3）本质仍然是一个类

```java
/*
练习实例1
1.编一个类A，在类中定义局部内部类B，B中有一个私有常量 NAME ，有一个方法show()打
印常量name。进行测试
2.进阶：A中也定义一个私有的变量 name，在show方法中打印测试
 */

class LocalA{
    private String name = "variable A";
    public void f1(){
        class B{
            private final String NAME = "constant B";//常量用 final 修饰，用大写命名
            public void show(){
                //如果有属性重名，需要 外部类名.this.属性名
                System.out.println("局部内部类 NAME = " + NAME + "，外部类 name = " + name);
            }
        }
        B b = new B();//局部内部类需要在方法体中创建此类，否则无法调用内部类的功能
        b.show();
    }
}
class LocalAExercise{
    public static void main(String[] args) {
        new LocalA().f1();
    }
}
```



## 匿名内部类

涉及到继承、多态、动态绑定、内部类
1）类   2）内部类   3）没有名字   4）是一个对象
说明：匿名内部类是定义在外部类的局部位置，比如方法中，并且没有类名

1.匿名内部类的基本语法

```java
new 类或接口(参数列表){
	类体
};
```



//匿名内部类就是实现了某个接口或继承某个父类的实例对象，重写了方法，这里是向上转型的
//匿名内部类作为实参的时候看成对象，接收后动态绑定匿名内部类

2.匿名内部类的语法比较奇特。因为匿名内部类既是一个类的定义，同时它本身也是一个对象。
因此从语法上看，它既有定义类的特征，也有创建对象的特证，

3.可以直接访问外部类的所有成员，包含私有的
4.不能添加访问修饰符,因为它的地位就是一个局部变量。
5．作用域：仅仅在定义它的方法或代码块中。
6.匿名内部类 -访问-> 外部类成员[访问方式：直接访问]
7.外部其他类 -不能访问-> 匿名内部类（因为匿名内部类只是一个局部变量）
8.如果外部类和内部类的成员重名时，内部类访问的话，默认遵循就近原则，如果想
访问外部类的成员，则可以使用（外部类名.this.成员）去访问

//匿名内部类需要分号，因为匿名内部类需要立即创建对象，创建对象语句是需要分号的

```java
interface USB {//接口
    void use();
}

class NestedAnonymousExample1 {
    //静态方法，形参是接口类型
    public static void f1(USB usb){
        usb.use();
    }
    
    public static void main(String[] args) {
        //匿名内部类可以当做实参直接传递，简洁高效
        f1(new USB() {//这个new的意思是匿名内部类,底层意思其实是弄了一个类来实例化这个匿名内部类的，相当于直接传入一个对象
            @Override
            public void use() {
                System.out.println("直接调用 USB 接口");
            }
        });
        //传统方法：需要新建类才能实现接口调用
        f1(new USB3());
    }
}

/*
匿名内部类的最佳实践：当做实参直接传递。
应该便于那些复用性不高的类，创建会浪费资源，不如一次性的，用完就丢/同时都需要改的话，硬编码改一个都改了，两种方法优劣不一样，根据情况使用
 */
class USB3 implements USB {
    //这种方式被称作硬编码
    @Override
    public void use() {
        System.out.println("新建外部类实现 USB 接口");
    }
}
//使用匿名内部类可以省略新建这个类的过程，直接在运行过程中完成调用
```



## 成员内部类

说明：成员内部类定义在外部类的成员位置(不在代码块和其他方法中)，并没有 static 修饰
1.可以直接访问外部类的所有成员，包含私有的
2.可以添加任意访问修饰符（public、protected、默认、private）因为它的地位就是一个成员。
3.作用域：和外部类的其他成员一样，为整个类体
比如前面案例，在外部类的成员方法中创建成员内部类对象，再调用方法
4.成员内部类---访问---->外部类（比如：属性）[访问方式：直接访问]
5.外部类---访问------>内部类（说明）[访问方式：创建对象，再访问]
6.外部其他类--访问---->成员内部类[两种方法]
7.如果外部类和内部类的成员重名时，内部类访问的话，默认遵循就近原则，如果想访问外部类的成员，则可以使用（外部类名.this.成员）去访问



## 静态内部类

说明：静态内部类是定义在外部类的成员位置，并且有static修饰
1.可以直接访问外部类的所有静态成员，包含私有的，但不能直接访问静态成员
2.可以添加任意访问修饰符（public、protected、默认、private）.因为它的地位就是一个成员
3.作用域：同其他的成员，为整个类体
4.静态内部类 -访问-> 外部类（比如：静态属性）[访问方式：直接访问所有静态成员]
5.外部类 -访问-> 静态内部类[访问方式：创建对象，再访问]
6.外部其他类 -访问-> 静态内部类[
7，如果外部类和静态内部类的成员重名时，静态内部类访问的时，默认遵循就近原则，如果想访问外部类的成员，则可以使用（外部类名成员）去访问


成员内部类、静态内部类就是一个外部类的一个成员，里面可以放多个属性或者变量，访问规则和本类调用规则一样
静态内部类绝不能用this访问，所有静态方法也一样，this，super都不能用


# 泛型

使用传统方法的问题分析
1)不能对加入到集合ArrayList中的数据类型进行约束(不安全）
2）遍历的时候，需要进行类型转换，如果集合中的数据量较大，对效率有影响

泛型的好处
1）编译时，检查添加元素的类型，提高了安全性[以前集合是可以放入任何对象，加入泛型后只能放入同一类型的对象]
2）减少了类型转换的次数，提高效率[传统的没有泛型声明的集合默认Object，没有自定义类的独有方法，传入时自动向上转型，使用时需要另外向下转型]
3）不再提示编译警告

泛型介绍
//其实泛型的翻译非常不准确，应该翻译为约束类型，类似C++的模板函数和模板类。
//泛型的主要功能就是限制集合元素类型，约束传入集合的类型，约束返回值的类型
1）泛型又称参数化类型，是Jdk5.0出现的新特性，解决数据类型的安全性问题
2）在类声明或实例化时只要指定好需要的具体的类型即可。
3）Java泛型可以保证如果程序在编译时没有发出警告，运行时就不会产生 ClassCastException 异常。同时， 代码更加简洁、健壮
4）泛型的作用是：可以在类声明时通过一个标识表示类中某个属性的类型，或者是某个方法的返回值的类型，或者是参数类型。
//编译器是不知道泛型的，真正编译之后他尖括号会消失，然后相关的e会变成你指定的类型，反编译就可以看到

泛型的语法
泛型的声明
interface 接口<T>{} 和 class 类<K,V>{}
//比如: List , ArrayList
说明：
1)其中，T,K,V不代表值，而是表示类型
2)任意字母都可以。常用T表示，是Type的缩写

泛型的实例化：
要在类名后面指定类型参数的值（类型）。如：
1) List<String> strList = new ArrayList<String>{};
2) Iterator<Customer> iterator = customers.iteratorO

使用细节：
1、类型参数要求是引用类型，不能是基本数据类型Type argument cannot be of primitive type
2、在给泛型指定具体类型后，可以传入该类型或者其子类类型
3、等号右边可以不写实参的泛型类型，编译器会自行判断（推荐使用）java核心技术称这个写法为菱形写法
4、不给泛型指定具体数据类型时，默认为Object



自定义泛型类
基本语法
class 类名<T, R...> {
成员
}
注意细节
1）普通成员(属性、方法)可以使用泛型
2）使用泛型的数组，不能初始化Type parameter cannot be instantiated directly(类型擦除：运行时数组不能确定泛型类型，无法在内存开空间)
3）静态方法中不能使用类的泛型（泛型在类实例化时才传递类型参数，静态方法的加载先于类的实例化）
    ->类加载的情况：1.创建类对象 2.子类加载父类就加载 3.调用静态属性，静态方法
4）泛型类的类型，是在创建对象时确定的(因为创建对象时，需要指定确定类型）
5）如果在创建对象时，没有指定类型，默认为Object
6）T, R, M 泛型的标识符, 一般是单个大写字母

自定义泛型接口
基本语法
interface接口名<T, R...> {
}
注意细节
1）接口中，静态成员也不能使用泛型（这个和泛型类规定一样
2）泛型接口的类型，在继承接口或者实现接口时确定
3）没有指定类型，默认为Object



自定义泛型方法
基本语法
修饰符<T,R..>返回类型 方法名（参数列表）（
}

注意细节
1.泛型方法，可以定义在普通类中，也可以定义在泛型类中
2.当泛型方法被调用时，类型会确定
3.public void eat(E e){},修饰符后没有<T,R..> 这个方法不是泛型方法，而是使用了泛型的普通方法

//重载是一定要先指定你形参类型，这里用泛型的好处就是可以不用先确定形参类型
//静态的泛型方法只能用自己方法上定义的<>。不能用类上定义的


泛型的继承和通配符说明
1）泛型不具备继承性
List<Object> list = new ArrayList<String>(); // 错误
2）<?>：支持任意泛型类型
3）<? extendsA>：支持A类以及A类的子类，规定了泛型的上限
4)<? superA>：支持A类以及A类的父类，不限于直接父类，规定了泛型的下限

方法参数有无<?>的区别: 当存在返回集合时，如果没有<?>将自动返回Object集合，加入<?>将返回 ？类型的集合
可以不用定义泛型类，也能让方法使用泛型
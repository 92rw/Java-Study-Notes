# 线程

进程的概念、线程接口及实现类、代理模式
/*
1.程序(program)：是为完成特定任务、用某种语言编写的一组指令的集合。简单的说：就是我们写的代码

2.进程(Process)：
1）进程是指运行中的程序，比如我们使用QQ，就启动了一个进程，操作系统就会为该进程分配内存空间。
2）进程是程序的一次执行过程，或是正在运行的一个程序。是动态过程：有它自身的产生、存在和消亡的过程

3.线程(Thread)：
1）线程由进程创建的，是进程的一个实体
2）一个进程可以拥有多个线程

线程是操作系统调度的基本单位，进程是操作系统分配资源的基本单位

其他概念：
1.单线程：同一个时刻，只允许执行一个线程
2.多线程(MultiThread)：同一个时刻，可以执行多个线程
3.并发(Concurrency)：同一时间段，多个任务交替执行，造成一种“貌似同时”的错觉。简单的说，单核cpu实现的多任务就是并发
4.并行(Parallelism)：同一个时刻，多个任务同时执行。多核cpu可以实现并行

创建线程的两种方式
在java中线程来使用有两种方法。
1.继承Thread类，重写run方法
2.实现Runnable接口，重写run方法





/*
用静态代理模式去创建新线程就是弥补java单继承缺陷，同时提高Thread类的复用性（创建新线程都由Thread完成，
自定义其他类只需编好新线程的业务逻辑，再通过代理类去复用Thread的创建线程功能）
1、java单继承，若自定义Lion已继承了其他类，就无法再继承Thread类，lion对象也就不能直接使用Thread类的start和start0方法创建新线程
2、既然无法直接调用start方法，就让tiger借用代理类Thread去间接调用这两个方法。也就是在Thread中构造
一个可传入Runnable接口实现类对象的构造方法接收tiger对象(参数多态)
3、由于Thread实现了Runnable接口，所以也从接口处获得了run方法，但是Thread这个run方法不自己实现逻辑，而是调用传入的lion对象的run方法（LionRoar类重写run方法的业务逻辑）
4、Thread对象创建新线程时调用本身start，start调用底层start0，start0又回调它本身的run，但此刻Thread的run方法已经调用了传入的LionRoar类对象重写的run业务逻辑
5、所以负责创建线程的还是Thread的start方法，但是线程业务逻辑绑定到自定义类内run方法，这样任何类想创建线程实现自己业务逻辑都只需实现R接口重写run方法，再向代理类传入对象就可实现
PS：这个Proxy代理类只是模拟Thread代理类内的run方法动态调用过程，方便理解静态代理逻辑和创建线程的方法调用过程，并没有真正实现新线程创建

说一下线程这样设计的意义，最根本的意义就在于解耦，权责分明，创建线程交给Thread类，创建线程任务交给实现了Runnable接口的任意类
这样做的好处有三点：
1、解除类的单继承限制，更好的实现多线程；
2、解耦之前，线程任务改动需要修改run方法（），解耦之后，只需要修改外部类，实现非侵入式的修改，提高代码的可扩展性，这是接口的主要好处。
3、线程任务执行完后，不需要再次创建销毁线程，只需要实现Runnable接口提交新的线程任务即可，提高性能节省开销，后面的线程池设计主要体现这一点

需要满足的条件
1. 代理类和被代理类要实现同一个接口 2. 代理的构造方法中传入被代理对象 3. 代理调用接口中的某个方法，但实际的运行类型是被代理的类型



以前是多态，父类类型的接口接收然后调用子类方法，现在是换了一个方向，一个实现类接收父类类型的另一个分支的实现类对象，反过来利用多态调用方法

继承Threadvs实现Runnable的区别
1.从java的设计来看，通过继承Thread或者实现Runnable接口来创建线程本
质上没有区别，从jdk帮助文档我们可以看到Thread类本身就实现了Runnable接口
2.实现Runnable接口方式更加适合多个线程共享一个资源的情况，并且避免了单继承的限制

//继承Thread的话创建一个新的线程都要建立一个新的对象，实现Runnable接口可以创建一个对象多次传入Thread
//实际开发中建议采用Runnable接口实现的方式
 */



```
class CPUCount {
    public static void main(String[] args) {
        Runtime runtime = Runtime.getRuntime();
        //获取当前电脑的cpu数量/核心数
        int cpuNums = runtime.availableProcessors();
        //cpu的线程指的是逻辑处理器(Logical processors)，和java的线程(thread)不是一个概念
        System.out.println("当前有cpu 个数=" + cpuNums);
    }
}
```





直接调用`run()`方法，相当于调用了一个普通的Java方法，当前线程并没有任何改变，也不会启动新线程。上述代码实际上是在`main()`方法内部又调用了`run()`方法，打印`hello`语句是在`main`线程中执行的，没有任何新线程被创建。

必须调用`Thread`实例的`start()`方法才能启动新线程，如果我们查看`Thread`类的源代码，会看到`start()`方法内部调用了一个`private native void start0()`方法，`native`修饰符表示这个方法是由JVM虚拟机内部的C代码实现的，不是由Java代码实现的。

### 线程的优先级

可以对线程设定优先级，设定优先级的方法是：

```java
Thread.setPriority(int n) // 1~10, 默认值5
```

JVM自动把1（低）~10（高）的优先级映射到操作系统实际优先级上（不同操作系统有不同的优先级数量）。优先级高的线程被操作系统调度的优先级较高，操作系统对高优先级线程可能调度更频繁，但我们决不能通过设置优先级来确保高优先级的线程一定会先执行。

# 正则表达式（Regular Expression）

处理文本的利器，对字符串执行模式匹配的技术。这些东西完整的可以看JDK文档的Pattern类

## 常用类和方法

Java 中的 `String` 类提供了支持正则表达式操作的方法，包括：`matches()`、`replaceAll()`、`replaceFirst()`、`split()`。此外，Java 中可以用 `Pattern` 类表示正则表达式对象，它提供了丰富的 API 进行各种正则表达式操作



java.util.regex包主要包括以下三个类：Pattern类、Matcher类和PatternSyntaxException类

* Pattern类
  pattern对象是一个正则表达式对象。Pattern类没有公共构造方法。要创建一个Pattern对象，调用其公共静态方法，它返回一个Pattern对象。该方法接受一个正则表达式作为它的第一个参数，比如：

  ```Pattern r = Pattern.compile(pattern);```

  * matches(regStr, content)方法用于整体匹配，在判断输入的字符串是否满足条件是比较简洁（省略了定位符），返回值为布尔类型（底层调用了Matcher类的matches方法）
  * Pattern.matcher.find方法适合从大篇幅文章中查找某个规格的子字符串，matches方法只是检索内容规格是否正确（对字符串整体进行验证）

* Matcher类
  Matcher对象是对输入字符串进行解释和匹配的引擎。与Pattern类一样，Matcher也没有公共构造方法。你需要调用Pattern对象的matcher方法来获得一个Matcher对象

| 方法                                                         | 说明                                                         |
| ------------------------------------------------------------ | ------------------------------------------------------------ |
| public int start()                                           | 返回以前匹配的初始索引                                       |
| public int start(int group)                                  | 返回在以前的匹配操作期间，由给定组所捕获的子序列的初始索引   |
| public int end()                                             | 返回最后匹配字符之后的偏移量。                               |
| public int end(int group)                                    | 返回在以前的匹配操作期间，由给定组所捕获子序列的最后字符之后的偏移量 |
| public boolean lookingAt()                                   | 尝试将从区域开头开始的输入序列与该模式匹配                   |
| public boolean find()                                        | 尝试查找与该模式匹配的输入序列的下一个子序列                 |
| public boolean find(int start                                | )重置此匹配器，然后尝试查找匹配该模式、从指定索引开始的输入序列的下一个子序列。 |
| public boolean matches()                                     | 尝试将整个区域与模式匹配                                     |
| public Matcher  appendReplacement (StringBuffer sb, String replacement) | 实现非终端添加和替换步骤                                     |
| public StringBuffer  appendTail (StringBuffer sb)            | 实现终端添加和替换步骤                                       |
| public String replaceAll(String  replacement)                | 替换模式与给定替换字符串相匹配的输入序列的每个子序列         |
| public String replaceFirst(String  replacement)              | 替换模式与给定替换学符串匹配的输入序列的第一个子序列         |
| public static String  quoteReplacement(String s)             | 返回指定字符串的字面替换字符串。这个方法返回一个字符串，就像传递给Matcher类的appendReplacement方法一个字面字符串一样工作 |



* PatternSyntaxException类
  PatternSyntaxException是一个非强制异常类，它表示一个正则表达式模式中的语法错误





## 正则表达式语法

如果要想灵活的运用正则表达式，必须了解其中各种元字符的功能，元字符从功能上大致分为：

* 限定符
* 选择匹配符
* 分组组合和反向引用符
* 特殊字符
* 字符匹配符
* 定位符





转义字符```\\```，用于检索特殊字符 ```*+()$/\?[]^{}.```

在java的正则表达式中，两个斜杠代表其他语言中的一个斜杠

### 字符匹配符

| 符号      | 类型                                                         | 示例               | 解释                                                 | 匹配输入               |
| --------- | ------------------------------------------------------------ | ------------------ | ---------------------------------------------------- | ---------------------- |
| []        | 可接收的字符列表                                             | [efgh]             | e、f、g、h中的任意一个字符                           |                        |
| [^]       | 不接收的字符列表                                             | [^abc]             | 除a、b、c之外的任意1个字符除，包括数字和特殊符号     |                        |
| -         | 连字符                                                       | A-Z                | 任意单个大写字母                                     |                        |
| .         | 匹配除换行符（\r，\n）以外的任何字符（类似MySQL的_），如果匹配"."需要使用```\\.``` | a..b               | 以a开头，b结尾，中间包括2个任意字符的长度为4的字符串 | aaab、aefb、a35b、a#*b |
| ```\\d``` | 匹配单个数字(digital)字符，相当于[0-9]                       | ```\\d{3}(\\d)?``` | 包含3个或4个数字的字符串                             | 123、9876              |
| ```\\D``` | 匹配单个非数字字符，相当于```[^0-9]```                       | ```\\D(\\d)*```    | 以单个非数字字符开头，后接任意个数字字符串           | a、A342                |
| ```\\w``` | 匹配单个数字、大小写字母字符或下划线，相当于[0-9a-zA-Z_]，可以记成类的命名范围 | ```\\d{3}(\\d)?``` | 以3个数字字符开头的长度为7的数字字母字符串           | 234abcd、12345Pe       |
| ```\\W``` | 匹配单个非数字、大小写字母字符或下划线，相当于```[^0-9a-zA-Z_]``` | ```\\W+\\d{2}```   | 以至少1个非数字字母字符开头，2个数字字符结尾的字符串 | #29、#?@10             |
| ```\\s``` | 匹配任何空白字符（空格、制表、换行符等）                     |                    |                                                      |                        |
| ```\\S``` | 匹配任何非空白字符                                           |                    |                                                      |                        |

java正则表达式默认是区分字母大小写的，如何实现不区分大小写

- (?i)abc：表示abc都不区分大小写
- a(?i)bc：表示bc不区分大小写
- a((?i)b)c：表示只有b不区分大小写
- 创建Pattern对象时指定```Pattern pat = Pattern.compile(regEx, Pattern.CASE_INSENSITIVE);```
- 说明：A-z在ASCII码表中有[\]^_`这些字符，因此不能用A-z表示字母







### 选择匹配符

| 符号 | 类型                       | 示例   | 解释     | 匹配输入 |
| ---- | -------------------------- | ------ | -------- | -------- |
| \|   | 匹配"\|"之前或之后的表达式 | ab\|cd | ab或者cd |          |

### 限定符

用于指定其前面的字符和组合项连续出现多少次

| 符号  |             类型             |    示例     |                   解释                   |    匹配输入    |
| :---: | :--------------------------: | :---------: | :--------------------------------------: | :------------: |
|   ?   | 指定字符可有可无（0次或1次） |   m+abc?    |   以至少1个m开头，后接ab或abc的字符串    |  mmab、mabc、  |
|   +   |     指定字符重复1次以上      |  m+(abc)*   |  以至少1个m开头，后接任意个abc的字符串   |   m、mmmabc    |
|   *   | 指定字符重复任意次（0~任意） |   (abc)*    |    仅包含任意个abc的字符串，等效于\w*    | abc、abcabcabc |
|  {n}  |       只能输入n个字符        |  [abcd]{3}  |  由abcd中字母组成的任意长度为3的字符串   | dcb、cba、adc  |
| {n,}  |       指定至少n个匹配        | [abcd]{3,}  | 由abcd中字母组成的任意长度[3,+∞)的字符串 |      aab       |
| {n,m} |    指定至少n个至多m个匹配    | [abcd]{3,5} | 由abcd中字母组成的任意长度[3,5]的字符串  |  aaaaa、bcda   |

备注：

- 没有括号时，限定符只作用在最近位置；
- 除非语句要求限定长度，否则语法都会尽量长的返回字符串（默认贪婪匹配）
- 要求非贪恋匹配时，在其他限定符(*、+、?、{n}、{n,}、{n,m})之后加上问号"?"即可
- 对于匹配字段的中间部分无要求，可以写成".*"



### 定位符

规定要匹配的字符串出现的位置，比如在字符串的开始还是在结束的位置

定位符，是对字符串文本进行校验，而非匹配搜寻对应的字段

|   符号    |          类型          |          示例          |                             解释                             |           匹配输入           |
| :-------: | :--------------------: | :--------------------: | :----------------------------------------------------------: | :--------------------------: |
|     ^     |      指定起始字符      |     ^[0-9]+[a-z]*      |        以至少1个数字开头，后接任意个小写字母的字符串         |       123、6aa、555edc       |
|     $     |      指定结束字符      | ```^[0-9]\\-[a-z]+$``` | 以1个数字开头后接连字符"-”，并以至少1个小写字母结尾的字符串  |             1-a              |
| ```\\b``` |  匹配目标字符串的边界  |      ```nya\\b```      | 这里说的字符串的边界指的是子串间有空格、制表符、换行符，或者是目标字符串的结束位置 | nyameowmeow**nya** nn**nya** |
| ```\\B``` | 匹配目标字符串的非边界 |      ```nya\\B```      |         不在子串结尾处的nya（和 ```\\b``` 含义相反）         |   **nya**meowmeownya nnnya   |

### 分组

| 常用的分组构造形式     | 说明                                                         |
| ---------------------- | ------------------------------------------------------------ |
| (pattern)              | 非命名捕获。捕获匹配的子字符串。编号为零的第一个捕获是由整个正则表达式模式匹配的文本，其它捕获结果则根据左括号的顺序从1开始自动编号 |
| ```(?<name>pattern)``` | 命名捕获。将匹配的子学符捕获到一个组名称或编号名称中。用于name的字符串不能包含任何标点符号，并不能以数字开头。可以便用单引号替代尖括号，例如(?'name‘) |
| (?:pattern)            | 匹配pattern但不捕获该匹配的子表达式，即它是一个非捕获匹配，不存储供以后使用的匹配。这对于用"or“字符（\|）组合模式部件的情况很有用。例如，“industr(?:y\|ies)" 是比 'industry\|industries' 更经济的表达式 |
| (?=pattern)            | 它是一个非捕获匹配。例如，'Windows(?=95\|98\|NT\|2000)' 匹配 "Windows2000"中的"Windows"，但不匹配"Windows3.1"中的Windows |
| (?!pattern)            | 该表达式匹配不处于匹配pattern的字符串的起始点的搜索字符串。它是一个非捕获匹配。例如，'Windows(?!95\|98\|NT\|2000)' 匹配 "Windows3.1" 中的 "Windows" ，但不匹配 "Windows2000" 中的 "Windows" |

(?:)捕获括号内+括号前，而(?=)根据括号内捕获括号前的字符串，(?!)根据非括号内捕获括号前的字符串



1.分组
我们可以用圆括号组成一个比较复杂的匹配模式，那么一个圆括号的部分我们可以看作是一个子表达式/一个分组。
2.捕获
把正则表达式中子表达式/分组匹配的内容，保存到内存中以数字编号或显式命名的组里，方便后面引用，从左向右，以分组的左括号为标志，第一个出现的分组的组号为1，第二个为2，以此类推。组0代表的是整个正则式
3.反向引用
圆括号的内容被捕获后，可以在这个括号后被使用，从而写出一个比较实用的匹配模式，这个我们称为反向引用，这种引用既可以是在正则表达式内部，也可以是在正则表达式外部，内部反向引用 ```\\``` 分组号，外部反向引用 ```$``` 分组号



### 其他字符

| 其他字符 | 说明                                                         |
| -------- | ------------------------------------------------------------ |
| \cx      | 匹配x指示的控制字符。例如，\cM匹配Control-M或回车符。x的值必须在A-z或a-z之间。如果不是这样，则假定c就是“c"字符本身。 |
| \f       | 换页符匹配，等效于 \x0c 和 \cL                               |
| \n       | 换行符匹配，等效于 \x0a 和\cJ                                |
| \r       | 回车符匹配，等效于 \x0d 和\cM                                |
| \t       | 制表符匹配，等效于 \x09 和\cI                                |
| \v       | 垂直制表符匹配，等效于 \x0b 和\cK                            |
| \xn      | 匹配n，此处的n是一个十六进制转义码。十六进制转义码必须正好是两位数长。例如，"\x41" 匹配 "A"。"x041" 与 "x04"&"1" 等效。允许在正则表达式中使用ASCIl代码。 |
| \num     | 匹配num，此处的num是一个正整数。捕获匹配的反向引用。例如，“(.)\1"匹配两个连续的相同字符。 |
| \n       | 标识一个八进制转义码或反向引用。如果\n前面至少有n个捕获子表送式，那么n是反向引用。否则，如果n是八进制数（0-7），那么n是八进制转义码。 |
| \nm      | 标识一个八进制转义码或反向引用。如果\nm前面至少有nm个捕获子表送式，那么nm是反向引用。如果\nm前面至少有n个捕获，则n是反向引用，后面跟有字符m。如果两种前面的情况都不存在，则\nm匹配八进制值nm，其中n和m是八进制数字（0-7）。 |
| \nml     | 当n是八进制数（0-3)，m和l是八进制数（0-7）时，匹配八进制转义码nml |
| \un      | 匹配n，其中n是以四位十六进制数表示的Unicode字符。例如，\u00A9匹配版权符号"©"。 |



说明：

* 需要考虑转义的符号包括（. * + ( ) $ / \ ? [ ] ^ { }）
* 在方括号“[]”内的特殊字符表示其本身，不带有任何含义，里面出现的任意字符只要有就会匹配上



### 表达式嵌套

子表达式允许嵌套，多重嵌套的子表达式可以构造出功能极其强大的正则表达式来，但是难免会让模式变得难以阅读和理解。

如何匹配一个`IP 地址`？

一个合法的 IP 地址里的各组数字必须满足：

- 任何一个 1 位或 2 位数字
- 任何一个以 1 开头的 3 位数字
- 任何一个以 2 开头、第 2 位数字在 0~5 之间的 3 位数字
- 任何一个以 25 开头、第 3 位数字在 0~5 之间的 3 位数字

正则表达式

```
(((\d{1,2})|(1\d{2})|(2[0-4]\d)|(25[0-5]))\.){3}((\d{1,2})|(1\d{2})|(2[0-4]\d)|(25[0-5]))
```



## 常用的正则表达式

一、校验数字的表达式

```
1 数字：^[0-9]*$
2 n位的数字：^\d{n}$
3 至少n位的数字：^\d{n,}$
4 m-n位的数字：^\d{m,n}$
5 零和非零开头的数字：^(0|[1-9][0-9]*)$
6 非零开头的最多带两位小数的数字：^([1-9][0-9]*)+(.[0-9]{1,2})?$
7 带1-2位小数的正数或负数：^(\-)?\d+(\.\d{1,2})?$
8 正数、负数、和小数：^(\-|\+)?\d+(\.\d+)?$
9 有两位小数的正实数：^[0-9]+(.[0-9]{2})?$
10 有1~3位小数的正实数：^[0-9]+(.[0-9]{1,3})?$
11 非零的正整数：^[1-9]\d*$ 或 ^([1-9][0-9]*){1,3}$ 或 ^\+?[1-9][0-9]*$
12 非零的负整数：^\-[1-9][]0-9"*$ 或 ^-[1-9]\d*$
13 非负整数：^\d+$ 或 ^[1-9]\d*|0$
14 非正整数：^-[1-9]\d*|0$ 或 ^((-\d+)|(0+))$
15 非负浮点数：^\d+(\.\d+)?$ 或 ^[1-9]\d*\.\d*|0\.\d*[1-9]\d*|0?\.0+|0$
16 非正浮点数：^((-\d+(\.\d+)?)|(0+(\.0+)?))$ 或 ^(-([1-9]\d*\.\d*|0\.\d*[1-9]\d*))|0?\.0+|0$
17 正浮点数：^[1-9]\d*\.\d*|0\.\d*[1-9]\d*$ 或 ^(([0-9]+\.[0-9]*[1-9][0-9]*)|([0-9]*[1-9][0-9]*\.[0-9]+)|([0-9]*[1-9][0-9]*))$
18 负浮点数：^-([1-9]\d*\.\d*|0\.\d*[1-9]\d*)$ 或 ^(-(([0-9]+\.[0-9]*[1-9][0-9]*)|([0-9]*[1-9][0-9]*\.[0-9]+)|([0-9]*[1-9][0-9]*)))$
19 浮点数：^(-?\d+)(\.\d+)?$ 或 ^-?([1-9]\d*\.\d*|0\.\d*[1-9]\d*|0?\.0+|0)$
```


二、校验字符的表达式

```
1 汉字：^[\u4e00-\u9fa5]*$
2 英文和数字：^[A-Za-z0-9]+$ 或 ^[A-Za-z0-9]{4,40}$
3 长度为3-20的所有字符：^.{3,20}$
4 由26个英文字母组成的字符串：^[A-Za-z]+$
5 由26个大写英文字母组成的字符串：^[A-Z]+$
6 由26个小写英文字母组成的字符串：^[a-z]+$
7 由数字和26个英文字母组成的字符串：^[A-Za-z0-9]+$
8 由数字、26个英文字母或者下划线组成的字符串：^\w+$ 或 ^\w{3,20}$
9 中文、英文、数字包括下划线：^[\u4E00-\u9FA5A-Za-z0-9_]+$
10 中文、英文、数字但不包括下划线等符号：^[\u4E00-\u9FA5A-Za-z0-9]+$ 或 ^[\u4E00-\u9FA5A-Za-z0-9]{2,20}$
11 可以输入含有^%&',;=?$\"等字符：[^%&',;=?$\x22]+
12 禁止输入含有~的字符：[^~\x22]+
```


三、特殊需求表达式

```
1 Email地址：^\w+([-+.]\w+)*@\w+([-.]\w+)*\.\w+([-.]\w+)*$
2 域名：[a-zA-Z0-9][-a-zA-Z0-9]{0,62}(/.[a-zA-Z0-9][-a-zA-Z0-9]{0,62})+/.?
3 InternetURL：[a-zA-z]+://[^\s]* 或 ^(https?://)?([\w-]+\.)+[\w-]+(/[\w-./?%&=#]*)?$
4 手机号码：^(13[0-9]|14[5|7]|15[0|1|2|3|5|6|7|8|9]|18[0|1|2|3|5|6|7|8|9])\d{8}$
5 电话号码("XXX-XXXXXXX"、"XXXX-XXXXXXXX"、"XXX-XXXXXXX"、"XXX-XXXXXXXX"、"XXXXXXX"和"XXXXXXXX)：^(\(\d{3,4}-)|\d{3.4}-)?\d{7,8}$ 
6 国内电话号码(0511-4405222、021-87888822)：\d{3}-\d{8}|\d{4}-\d{7}
7 身份证号：
		15或18位身份证：^\d{15}|\d{18}$
		15位身份证：^[1-9]\d{7}((0\d)|(1[0-2]))(([0|1|2]\d)|3[0-1])\d{3}$
		18位身份证：^[1-9]\d{5}[1-9]\d{3}((0\d)|(1[0-2]))(([0|1|2]\d)|3[0-1])\d{4}$
8 短身份证号码(数字、字母x结尾)：^([0-9]){7,18}(x|X)?$ 或 ^\d{8,18}|[0-9x]{8,18}|[0-9X]{8,18}?$
9 帐号是否合法(字母开头，允许5-16字节，允许字母数字下划线)：^[a-zA-Z][a-zA-Z0-9_]{4,15}$
10 密码(以字母开头，长度在6~18之间，只能包含字母、数字和下划线)：^[a-zA-Z]\w{5,17}$
11 强密码(必须包含大小写字母和数字的组合，不能使用特殊字符，长度在8-10之间)：^(?=.*\d)(?=.*[a-z])(?=.*[A-Z]).{8,10}$ 
12 日期格式：^\d{4}-\d{1,2}-\d{1,2}
13 一年的12个月(01～09和1～12)：^(0?[1-9]|1[0-2])$
14 一个月的31天(01～09和1～31)：^((0?[1-9])|((1|2)[0-9])|30|31)$ 
15 钱的输入格式：
16 1.有四种钱的表示形式我们可以接受:"10000.00" 和 "10,000.00", 和没有 "分" 的 "10000" 和 "10,000"：^[1-9][0-9]*$ 
17 2.这表示任意一个不以0开头的数字,但是,这也意味着一个字符"0"不通过,所以我们采用下面的形式：^(0|[1-9][0-9]*)$ 
18 3.一个0或者一个不以0开头的数字.我们还可以允许开头有一个负号：^(0|-?[1-9][0-9]*)$ 
19 4.这表示一个0或者一个可能为负的开头不为0的数字.让用户以0开头好了.把负号的也去掉,因为钱总不能是负的吧.下面我们要加的是说明可能的小数部分：^[0-9]+(.[0-9]+)?$ 
20 5.必须说明的是,小数点后面至少应该有1位数,所以"10."是不通过的,但是 "10" 和 "10.2" 是通过的：^[0-9]+(.[0-9]{2})?$ 
21 6.这样我们规定小数点后面必须有两位,如果你认为太苛刻了,可以这样：^[0-9]+(.[0-9]{1,2})?$ 
22 7.这样就允许用户只写一位小数.下面我们该考虑数字中的逗号了,我们可以这样：^[0-9]{1,3}(,[0-9]{3})*(.[0-9]{1,2})?$ 
23 8.1到3个数字,后面跟着任意个 逗号+3个数字,逗号成为可选,而不是必须：^([0-9]+|[0-9]{1,3}(,[0-9]{3})*)(.[0-9]{1,2})?$ 
24 备注：这就是最终结果了,别忘了"+"可以用"*"替代如果你觉得空字符串也可以接受的话(奇怪,为什么?)最后,别忘了在用函数时去掉去掉那个反斜杠,一般的错误都在这里
25 xml文件：^([a-zA-Z]+-?)+[a-zA-Z0-9]+\\.[x|X][m|M][l|L]$
26 中文字符的正则表达式：[\u4e00-\u9fa5]
27 双字节字符：[^\x00-\xff] (包括汉字在内，可以用来计算字符串的长度(一个双字节字符长度计2，ASCII字符计1))
28 空白行的正则表达式：\n\s*\r (可以用来删除空白行)
29 HTML标记的正则表达式：<(\S*?)[^>]*>.*?|<.*? /> (网上流传的版本太糟糕，上面这个也仅仅能部分，对于复杂的嵌套标记依旧无能为力)
30 首尾空白字符的正则表达式：^\s*|\s*$或(^\s*)|(\s*$) (可以用来删除行首行尾的空白字符(包括空格、制表符、换页符等等)，非常有用的表达式)
31 腾讯QQ号：[1-9][0-9]{4,} (腾讯QQ号从10000开始)
32 中国邮政编码：[1-9]\d{5}(?!\d) (中国邮政编码为6位数字)
33 IP地址：\d+\.\d+\.\d+\.\d+ (提取IP地址时有用)
```





参考资料

[30 分钟玩转「正则表达式」 · LjyYano/Thinking_in_Java_MindMapping](https://github.com/LjyYano/Thinking_in_Java_MindMapping/blob/master/编程/其他/30 分钟玩转「正则表达式」.md)

[正则表达式30分钟入门教程_脚本之家 (jb51.net)](https://www.jb51.net/tools/zhengze.html)

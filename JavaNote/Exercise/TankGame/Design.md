# 坦克大战

已实现的功能：坦克移动、爆炸、消失，记录击杀死亡数、存盘读取

涉及到的技术：  

- 面向对象编程
- 多线程
- 文件i/o操作
- 集合



## 目录下的文件含义

Tank.java - 所有坦克的父类，实现坦克的共有属性

MyTank.java - 己方坦克

EnemyTank.java - 敌方坦克

GamePanel.java - 定义画布（继承Graphics类），显示内容

GameFrame.java - 定义画框（继承JPanel类，实现KeyListener接口），游戏定义界面尺寸

Shot.java - 坦克射击炮弹

Explosion.java - 实现爆炸效果

TankModel.dwg - 用 AutoCAD 绘制的坦克模型样例，用于计算坦克模型中各个点的坐标

说明：需要将三个gif文件复制到 out\production\项目名 目录下，否则运行时会抛出空指针异常



## 游戏功能的代码实现

设计原理：

- 我方坦克和敌方坦克拥有不同的属性和方法，因此分别定义 MyTank 和 EnemyTank
- 敌方坦克数量多，存在多线程问题，放入 Vector 集合中
- 通过监听键盘按键，实现坦克移动、炮弹发射等动作
- 每个坦克是一个单独的线程，开火和移动又是这个线程的子线程

代码编写过程：

1. 绘制游戏界面
   GameFrame 继承 JFrame 并重写构造器，给（main）启动入口，设置画框、可见性和关闭程序的代码
   GamePanel 继承 JPanel 并重写 paint()方法，设置画布尺寸
   在 GamePanel 添加局部内部类 drawTank() 方法，设定坦克颜色和不同方向上的坦克图形

2. 绘制坦克图形
   提取坦克的共性到 Tank 类，我方坦克类和敌方坦克类分别继承此类
   在 GamePanel 中添加敌我坦克属性，在无惨构造器中初始化敌我坦克
   在 GamePanel 的 paint() 方法中绘制我方坦克，遍历绘制敌方坦克

3. 己方坦克移动
   让 GamePanel 类实现 KeyListener 接口，利用 keyPressed() 方法监听键盘WSAD键控制方向
   在监听到对应按键后，让我方坦克改变方向，并使用 repaint() 方法重绘画布（后续通过多线程自动刷新，该代码注销）
   在 GameFrame 的构造器中添加监听键盘的 addKeyListener 方法
   限制坦克移动区域：在父类 Tank 类新增方法，只有没碰到边界时才可移动

4. 敌方坦克移动
   敌方坦克类 EnemyTank 实现 Runnable 接口，重写run() 方法完成移动
   在 GamePanel 的构造器中给遍历出的敌方坦克添加线程并启动
   此时窗口不会自动刷新，只有我方坦克移动时才能看到地方的移动
   -> 让 GameFrame 实现 Runnable 接口，重写 run() 方法自动刷新画板
   -> 在 GameFrame 的构造器中启动 GamePanel 的线程

5. 按下J键发射炮弹：
   * 添加 Shot 类实现多线程接口，在run() 方法中根据初始方向持续移动，超出屏幕界面后自动销毁
   * 因为所有坦克都能发射炮弹，因此在 Tank 类中加入 Vector\<Shot> 集合，用于记录各个坦克发出的炮弹
   * 发射炮弹的过程是：以炮口的坐标、坦克方向新建 Shot 对象，启动线程并加入集合中
   * 在 MyTank 类新增 shotEnemy() 方法，当炮弹集合达到一定值、且炮弹未销毁则不执行方法，控制游戏中的炮弹数量
   * 在 keyPressed() 方法中，如果监听到键盘"J"键，就调用 shotEnemy() 方法
   * 将炮弹绘制在面板上：在GamePanel 的 paint() 方法中从集合中获取 Shot 对象，如果非空且尚未销毁，就绘制

6. 让敌人的坦克也能够发射炮弹
   * 每创建一个敌人坦克，就给其初始化一个 Shot 对象，同时启动 Shot
   * 在 EnemyTank 类的 run() 方法中，根据敌方坦克当前方向新建炮弹，执行线程并加入集合
   * 在绘制敌人坦克时，新增一段for循环用来遍历 Vector 并绘制炮弹，当炮弹销毁时从集合中移除

7. 炮弹击中坦克时，出现爆炸效果
   * 加入爆炸效果的图片，随界面刷新切换爆炸图
   * 在绘图中删掉坦克残骸和炮弹
   * 设置一个判断坦克是否被炮弹击中的方法，炮弹击中坦克后，从集合中删除，结束坦克线程，执行爆炸方法（设置爆炸过程的生命周期）
   * 如果坦克线程不结束，将成为空气墙，炮弹无法穿透

8. 防止敌人坦克相互碰撞
   * 移动之前循环遍历所有坦克的当前坐标，碰撞的时候不移动或者反向移动
   * 在EnemyTank类构造方法，获取GamePanel类中的Vector\<EnemyTank>集合
   * 遍历集合中的元素，判断是否和其他的坦克重叠
   * 移动方向上的前端和敌方坦克进行判断（其他方法：Rectangle 碰撞检测）

9. 玩游戏时，可以选择是开新游戏还是继续上局游戏
   1）新增Record类，实现功能：
   ①记录击毁敌方坦克数
   ②记录存活的敌人坦克坐标和方向 -> 当坦克被击中时需要反馈数据到 Record类
   ③读取记录在文件中的上述数据，将敌人坦克信息恢复成Node对象传入Vector集合
   2）当游戏结束时，调用Record类写入数据到myRecord.txt文件
   3）新建Node类，用于记录坦克信息
   4）在GamePanel类的构造器中，判断玩家是否选择继续游戏，执行相关代码

播放坦克大战音乐
引入AePlayWave.java文件
由于调用的这个类只能播放一次，修改为在坦克爆炸后播放


处理文件相关异常，提升健壮性
1）如果已经将敌方坦克全部摧毁，不保存记录
2）如果在没有记录的情况下选择“继续上一局”，处理文件异常
3）先判断记录文件是否存在，如果不存在，给出提示并开启新游戏

特别说明：
1、写并发程序，一定要考虑清楚该线程什么时候结束



## 未来的优化方向

1. 把所有可以画的物体类实现一个自己创建的Drawable接口，把所有对象保存在一个集合里，在paint里调用集合所有成员

2. 让玩家坦克也不会和敌方坦克重叠
3. 敌方坦克判断是否相互碰撞的代码需要重写



[返回主目录](https://github.com/92rw/Java-Study-Notes/tree/main)
